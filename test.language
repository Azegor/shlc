fn prt(chr i) native "prt_c";

fn hi()
{
  prt('H');
  prt('i');
  prt('\n');
}

fn testabc(int i) native;

fn loop()
{
//   whl T {
//     prt('.');
//   }
}

fn print_string();

fn main() {
  hi();
  4;
  3+4+3+4+2+5+234;
  1+2*3+4;
  //testabc(3+4);
  loop();
  print_string();
}

fn testasdfasdf(int i)
{
  i = 3+4+3+4+2+5+234*3+4*(5+6);
}

fn yo(){}

fn test(int a) {
  yo();
}

fn exit(int i) native;

fn bla(int a, b) {
  exit(1);
}

fn bla2(int a, b; flt c, d) {
  test(2);
}

fn whatever_fn_name(int a; flt b, c, d; chr e,f,g,h,i;boo l;) {
  yo();
}

fn declaration();
fn decl2(int a, b; flt c,d;);
fn decl3();

fn nativeFunction() native;
fn ANF(int a,b,c,d,e,f;boo g,h,i,j,k,l;) native;

// existing native functions:
fn sin(flt val) native;
fn cos(flt val) native;
fn tan(flt val) native;

//fn putc(chr c) native;

fn complex(int i)
{
  //ret 2*(3+4)*(5*6+7*8);
  whl T {
//     ret 42;
    ret;
  }
//   var i : int;
  do {
    i = 7;
  } whl F;
//   for j = 0; j < 7; j+=1
//   {
//     i += 2;
//   }
}

fn double() : flt {ret 1.2345;}
fn integer() : int {ret 123;}
fn boolean() : boo {ret T;}
fn char() : chr {ret 'c';}
//fn string() : str {ret "hi";}

fn duplicate();
fn duplicate();
fn duplicate();
fn duplicate();
fn duplicate() {}
fn duplicate();
fn duplicate();
fn duplicate();

//fn double(flt f) : flt { ret f; }

fn returnParam(int i) : int {ret i; }

fn whlVarTest(boo b; int i; flt f)
{
  whl b {
    ret;
  }
  whl i {
    ret;
  }
  whl f {
    ret;
  }
  4 : flt;
}

fn int_flt_cast(int i) : flt { ret i : flt; }
fn flt_int_cast(flt f) : int { ret f : int; }
fn int_chr_cast(int i) : chr { ret i : chr; }
fn chr_flt_cast(chr c) : flt { ret c : flt; }
fn chr_int_cast(chr c) : int { ret c : int; }
fn boo_int_cast(boo b) : int { ret b : int; }
fn boo_flt_cast(boo b) : flt { ret b : flt; }
fn chr_boo_cast(chr c) : boo { ret c : boo; }
fn flt_boo_cast(flt f) : boo { ret f : boo; }
// TODO: missing implicit cast for return statement??? let RetExpr check this!

fn assign_test(int i, j, k) : int
{
  i = k;
  i += j;
  // i += j += k; // broken, because wrong associativity for now! (FIXME)
  k = i + j * k;
  ret k;
}

fn local_vars(boo bl) : flt {
  var a : int;
  var b = 7;
  var c = 4.5;
  ret (bl*a+1) * (bl*b) + (bl*c);
}

fn break_test(boo b)
{
  whl b {
    brk;
    cnt;
    ret;
  }
  ret;
}

fn if_test(boo b)
{
  do {
    if b {
      cnt;
    } elif !b {
//     } elif b ^ b {
      brk;
    } el {
      ret;
    }
  } whl b;
}

fn test_bitcomp(int i; chr c; boo b) : int
{
  ret ~i | ~c&(b:chr) | (~b|i);
}

fn stringtest() : str
{
  var s = "yo";
  ret s;
  ret "somestringconst";
}

fn prt_s() native "prt_s";
fn print_string()
{
  prt_s("hi there\n");
  var i : int;
//   for i = 0; i < 100; i += 1 {
//     prt_s("<>");
//   }
  prt('\n');
}